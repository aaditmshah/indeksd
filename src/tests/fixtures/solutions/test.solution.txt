export type Value = 1 | 2 | 3;
export type Value2 = "1" | true | 0.2;
export type Value3 = Value | false;
export type Value4 = "some";
export type Authors = {
    id: number;
    name: string;
    email: string;
};
export type Post = {
    name: string;
    content: string;
};
export type AuthorsGetArgs = number | {
    name: string;
} | {
    email: string;
};
export type PostsGetArgs = {
    name: string;
};
const isAuthorsIdIndex = (arg: AuthorsGetArgs): arg is number => {
    return typeof arg === "object" && Reflect.has(arg, "id");
};
const isAuthorsNameIndex = (arg: AuthorsGetArgs): arg is {
    name: string;
} => {
    return typeof arg === "object" && Reflect.has(arg, "name");
};
const isAuthorsEmailIndex = (arg: AuthorsGetArgs): arg is {
    email: string;
} => {
    return typeof arg === "object" && Reflect.has(arg, "email");
};
const isPostsNameIndex = (arg: PostsGetArgs): arg is {
    name: string;
} => {
    return typeof arg === "object" && Reflect.has(arg, "name");
};
export type MyDatabaseClient = {
    authors: {
        add: (arg: Omit<Authors, "id">) => Promise<Authors>;
        get: (arg: AuthorsGetArgs) => Promise<Authors>;
    };
    posts: {
        add: (arg: Post) => Promise<Post>;
        get: (arg: PostsGetArgs) => Promise<Post>;
    };
};
function createDatabaseClient(db: IDBDatabase): MyDatabaseClient {
    return {
        authors: {
            add: (arg: Omit<Authors, "id">): Promise<Authors> => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(["Authors"], "readwrite");
                    const store = tx.objectStore("Authors");
                    const addRequest: IDBRequest = store.add(arg);
                    addRequest.onerror = event => {
                        reject((addRequest as IDBRequest).error);
                    };
                    addRequest.onsuccess = event => {
                        resolve((addRequest as IDBRequest).result);
                    };
                });
            },
            get: (arg: AuthorsGetArgs): Promise<Authors> => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(["Authors"], "readonly");
                    const store = tx.objectStore("Authors");
                    let getRequest: IDBRequest<Authors> | null = null;
                    if (isAuthorsNameIndex(arg)) {
                        const index: IDBIndex = store.index("name");
                        getRequest = index.get(arg.name);
                    }
                    else if (isAuthorsEmailIndex(arg)) {
                        const index: IDBIndex = store.index("email");
                        getRequest = index.get(arg.email);
                    }
                    else {
                        getRequest = store.get(arg);
                    }
                    if (getRequest != null) {
                        getRequest.onerror = event => {
                            reject((getRequest as IDBRequest).error);
                        };
                        getRequest.onsuccess = event => {
                            resolve((getRequest as IDBRequest).result);
                        };
                    }
                    else {
                        reject(new Error("No available index for given query"));
                    }
                });
            }
        },
        posts: {
            add: (arg: Post): Promise<Post> => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(["Posts"], "readwrite");
                    const store = tx.objectStore("Posts");
                    const addRequest: IDBRequest = store.add(arg);
                    addRequest.onerror = event => {
                        reject((addRequest as IDBRequest).error);
                    };
                    addRequest.onsuccess = event => {
                        resolve((addRequest as IDBRequest).result);
                    };
                });
            },
            get: (arg: PostsGetArgs): Promise<Post> => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(["Posts"], "readonly");
                    const store = tx.objectStore("Posts");
                    let getRequest: IDBRequest<Post> | null = null;
                    if (isPostsNameIndex(arg)) {
                        const index: IDBIndex = store.index("name");
                        getRequest = index.get(arg.name);
                    }
                    if (getRequest != null) {
                        getRequest.onerror = event => {
                            reject((getRequest as IDBRequest).error);
                        };
                        getRequest.onsuccess = event => {
                            resolve((getRequest as IDBRequest).result);
                        };
                    }
                    else {
                        reject(new Error("No available index for given query"));
                    }
                });
            }
        }
    };
}
export function init(): Promise<MyDatabaseClient> {
    return new Promise((resolve, reject) => {
        const DBOpenRequest = globalThis.indexedDB.open("MyDatabase");
        DBOpenRequest.onerror = event => {
            reject("Error opening database: MyDatabase");
        };
        DBOpenRequest.onsuccess = event => {
            const db = DBOpenRequest.result;
            resolve(createDatabaseClient(db));
        };
        DBOpenRequest.onupgradeneeded = event => {
            const db = DBOpenRequest.result;
            const AuthorsStore = db.createObjectStore("Authors", { keyPath: "id" });
            const PostsStore = db.createObjectStore("Posts", {});
            AuthorsStore.createIndex("name", "name", { unique: false });
            AuthorsStore.createIndex("email", "email", { unique: true });
            PostsStore.createIndex("name", "name", { unique: false });
        };
    });
}
