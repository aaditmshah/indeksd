export type Value = 1 | 2 | 3;
export type Value2 = '1' | true | 0.2;
export type Value3 = Value | false;
export type Value4 = 'some';
export type Value5 = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
export type Value6 = {
  firstName: string;
  lastName: string;
};
export type Value7 = [string, Value6];
export type Authors = {
  id: number;
  name: string;
  email: string;
};
export type Post = {
  postId: string;
  name: string;
  content?: string;
  author: number;
};
export type PostWithJoins = {
  postId: string;
  name: string;
  content?: string;
  author: Authors;
};
export type AuthorsIndexes = 'id' | 'name' | 'email';
export type PostsIndexes = 'postId' | 'name' | 'name_author' | 'author';
export type AuthorsWhereQueryType<IndexName extends AuthorsIndexes> =
  IndexName extends 'id'
    ? number
    : IndexName extends 'name'
    ? string
    : IndexName extends 'email'
    ? string
    : never;
export type PostsWhereQueryType<IndexName extends PostsIndexes> =
  IndexName extends 'postId'
    ? string
    : IndexName extends 'name'
    ? string
    : IndexName extends 'name_author'
    ? {
        name: string;
        author: number;
      }
    : IndexName extends 'author'
    ? number
    : never;
export type AuthorsAddArgs = {
  name: string;
  email: string;
};
export type PostsAddArgs = {
  postId: string;
  name: string;
  content?: string;
  author: number | AuthorsPutArgs;
};
export type AuthorsPutArgs =
  | AuthorsAddArgs
  | {
      id: number;
      name: string;
      email: string;
    };
export type PostsPutArgs =
  | PostsAddArgs
  | {
      postId: string;
      name: string;
      content?: string;
      author: number | AuthorsPutArgs;
    };
export type AuthorsDeleteArgs =
  | number
  | {
      id: number;
    };
export type PostsDeleteArgs =
  | string
  | {
      postId: string;
    };
export type AuthorsGetArgs =
  | number
  | {
      id: number;
    }
  | {
      name: string;
    }
  | {
      email: string;
    };
export type PostsGetArgs =
  | string
  | {
      postId: string;
    }
  | {
      name: string;
    }
  | {
      name: string;
      author: number;
    }
  | {
      author: number;
    };
const isAuthorsIdIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  id: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isAuthorsNameIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isAuthorsEmailIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  email: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'email')
  );
};
const isPostsPostIdIndex = (
  arg?: PostsGetArgs,
): arg is {
  postId: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'postId')
  );
};
const isPostsNameIndex = (
  arg?: PostsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isPostsNameAuthorIndex = (
  arg?: PostsGetArgs,
): arg is {
  name: string;
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 2 &&
    Reflect.has(arg, 'name') &&
    Reflect.has(arg, 'author')
  );
};
const isPostsAuthorIndex = (
  arg?: PostsGetArgs,
): arg is {
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'author')
  );
};
type RangeQuery<ArgType, ReturnType> = {
  isGreaterThan(arg: ArgType): ReturnType;
  isGreaterThanOrEqualTo(arg: ArgType): ReturnType;
  isLessThan(arg: ArgType): ReturnType;
  isLessThanOrEqualTo(arg: ArgType): ReturnType;
  isBetween(arg: { from: ArgType; to: ArgType }): ReturnType;
  isEqualTo(arg: ArgType): ReturnType;
};
export type AuthorsClient = {
  add(
    arg: AuthorsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  put(
    arg: AuthorsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  delete(
    arg: AuthorsDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: AuthorsGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  where<IndexName extends AuthorsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
    },
  ): RangeQuery<
    AuthorsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Authors>>
  >;
  sortBy(
    indexName: AuthorsIndexes,
    options?: {
      transaction?: IDBTransaction;
      count?: number;
    },
  ): Promise<ReadonlyArray<Authors>>;
};
export type PostsClient = {
  add(
    arg: PostsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Post>;
  put(
    arg: PostsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Post>;
  delete(
    arg: PostsDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): Promise<PostWithJoins>;
  get(
    arg: PostsGetArgs,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): Promise<Post>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): Promise<Post | PostWithJoins>;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): RangeQuery<
    PostsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<PostWithJoins>>
  >;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): RangeQuery<PostsWhereQueryType<IndexName>, Promise<ReadonlyArray<Post>>>;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): RangeQuery<
    PostsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>
  >;
  sortBy(
    indexName: PostsIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
      count?: number;
    },
  ): Promise<ReadonlyArray<PostWithJoins>>;
  sortBy(
    indexName: PostsIndexes,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
      count?: number;
    },
  ): Promise<ReadonlyArray<Post>>;
  sortBy(
    indexName: PostsIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
      count?: number;
    },
  ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>;
};
export type MyDatabaseClient = {
  transaction: (
    storeNames: Array<'Authors' | 'Posts'>,
    mode?: IDBTransactionMode,
  ) => IDBTransaction;
  authors: AuthorsClient;
  posts: PostsClient;
};
function createDatabaseClient(db: IDBDatabase): MyDatabaseClient {
  class AuthorsClientImpl {
    static tablesForTransaction: ReadonlyArray<string> = ['Authors'];
    add(
      arg: AuthorsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const [] = await Promise.all([]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            resolve({
              ...arg,
              id: DBAddRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: AuthorsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const [] = await Promise.all([]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            resolve({
              ...arg,
              id: DBPutRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: AuthorsDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        let DBDeleteRequest: IDBRequest | null = null;
        if (isAuthorsIdIndex(arg)) {
          DBDeleteRequest = store.delete(arg.id);
        } else {
          DBDeleteRequest = store.delete(arg);
        }
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: AuthorsGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        if (isAuthorsIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else if (isAuthorsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isAuthorsEmailIndex(arg)) {
          const index: IDBIndex = store.index('email');
          DBGetRequest = index.get([arg.email]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends AuthorsIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      AuthorsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Authors>>
    > {
      const tx =
        options?.transaction ?? db.transaction(['Authors'], 'readonly');
      const store = tx.objectStore('Authors');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Authors>>(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                resolve((DBGetRequest as IDBRequest).result);
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.only(query),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: AuthorsIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Authors>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'email': {
            const index: IDBIndex = store.index('email');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            return Promise.reject(
              new Error('Trying to run query on unknown index: ' + indexName),
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const authorsClient = new AuthorsClientImpl();
  class PostsClientImpl {
    static tablesForTransaction: ReadonlyArray<string> = ['Posts', 'Authors'];
    add(
      arg: PostsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Post> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        const [authorsId] = await Promise.all([
          new Promise<number>(async (resolve, reject) => {
            if (typeof arg.author === 'number') {
              resolve(arg.author);
            } else {
              try {
                const author = await authorsClient.put(arg.author, {
                  transaction: tx,
                });
                resolve(author.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        if (authorsId == null) {
          reject(
            new Error(
              'Unknown error occurred while trying to join table: Authors',
            ),
          );
          return;
        }
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
          author: authorsId,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            resolve({
              ...arg,
              author: authorsId,
              postId: DBAddRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: PostsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Post> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        const [authorsId] = await Promise.all([
          new Promise<number>(async (resolve, reject) => {
            if (typeof arg.author === 'number') {
              resolve(arg.author);
            } else {
              try {
                const author = await authorsClient.put(arg.author, {
                  transaction: tx,
                });
                resolve(author.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        if (authorsId == null) {
          reject(
            new Error(
              'Unknown error occurred while trying to join table: Authors',
            ),
          );
          return;
        }
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
          author: authorsId,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            resolve({
              ...arg,
              author: authorsId,
              postId: DBPutRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: PostsDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        let DBDeleteRequest: IDBRequest | null = null;
        if (isPostsPostIdIndex(arg)) {
          DBDeleteRequest = store.delete(arg.postId);
        } else {
          DBDeleteRequest = store.delete(arg);
        }
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): Promise<PostWithJoins>;
    get(
      arg: PostsGetArgs,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): Promise<Post>;
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): Promise<Post | PostWithJoins> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        if (isPostsPostIdIndex(arg)) {
          DBGetRequest = store.get(arg.postId);
        } else if (isPostsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isPostsNameAuthorIndex(arg)) {
          const index: IDBIndex = store.index('name_author');
          DBGetRequest = index.get([arg.name, arg.author]);
        } else if (isPostsAuthorIndex(arg)) {
          const index: IDBIndex = store.index('author');
          DBGetRequest = index.get([arg.author]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: Post = (DBGetRequest as IDBRequest).result;
              if (options?.withJoins != false) {
                Promise.all([
                  authorsClient.get(post.author, { transaction: tx }),
                ]).then(([author]) => {
                  resolve({
                    ...post,
                    author,
                  });
                });
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): RangeQuery<
      PostsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<PostWithJoins>>
    >;
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<PostsWhereQueryType<IndexName>, Promise<ReadonlyArray<Post>>>;
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): RangeQuery<
      PostsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>
    > {
      const tx =
        options?.transaction ?? options?.withJoins != false
          ? db.transaction(
              Array.from(
                new Set([
                  ...AuthorsClientImpl.tablesForTransaction,
                  ...PostsClientImpl.tablesForTransaction,
                ]),
              ),
              'readonly',
            )
          : db.transaction(['Posts'], 'readonly');
      const store = tx.objectStore('Posts');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>(
          async (resolve, reject) => {
            const DBGetRequest: IDBRequest = target.getAll(range);
            if (DBGetRequest != null) {
              DBGetRequest.onerror = () => {
                if (DBGetRequest != null) {
                  reject(DBGetRequest.error);
                } else {
                  reject(
                    new Error(
                      'Unknown error occurred trying to perform operation',
                    ),
                  );
                }
              };
              DBGetRequest.onsuccess = () => {
                if (DBGetRequest != null && DBGetRequest.result != null) {
                  const post: ReadonlyArray<Post> = (DBGetRequest as IDBRequest)
                    .result;
                  if (options?.withJoins != false) {
                    Promise.all(
                      post.map((result) => {
                        return Promise.all([
                          authorsClient.get(result.author),
                        ]).then(([author]) => {
                          return {
                            ...result,
                            author,
                          };
                        });
                      }),
                    ).then((result: ReadonlyArray<PostWithJoins>) => {
                      resolve(result);
                    });
                  } else {
                    resolve(post);
                  }
                } else {
                  reject(new Error('No result found for query'));
                }
              };
            } else {
              reject(new Error('No available index for given query'));
            }
          },
        );
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.lowerBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  true,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.lowerBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.upperBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  true,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.upperBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.bound(
                  [
                    (
                      query.from as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query.from as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  [
                    (
                      query.to as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query.to as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.only([
                  (
                    query as {
                      name: string;
                      author: number;
                    }
                  ).name,
                  (
                    query as {
                      name: string;
                      author: number;
                    }
                  ).author,
                ]),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.only(query),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: PostsIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
        count?: number;
      },
    ): Promise<ReadonlyArray<PostWithJoins>>;
    sortBy(
      indexName: PostsIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Post>>;
    sortBy(
      indexName: PostsIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
        count?: number;
      },
    ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'postId': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'name_author': {
            const index: IDBIndex = store.index('name_author');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'author': {
            const index: IDBIndex = store.index('author');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            return Promise.reject(
              new Error('Trying to run query on unknown index: ' + indexName),
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: ReadonlyArray<Post> = (DBGetRequest as IDBRequest)
                .result;
              if (options?.withJoins != false) {
                Promise.all(
                  post.map((result) => {
                    return Promise.all([authorsClient.get(result.author)]).then(
                      ([author]) => {
                        return {
                          ...result,
                          author,
                        };
                      },
                    );
                  }),
                ).then((result: ReadonlyArray<PostWithJoins>) => {
                  resolve(result);
                });
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const postsClient = new PostsClientImpl();
  return {
    transaction: (
      storeNames: Array<'Authors' | 'Posts'>,
      mode?: IDBTransactionMode,
    ): IDBTransaction => {
      return db.transaction(storeNames, mode);
    },
    authors: authorsClient,
    posts: postsClient,
  };
}
export function init(): Promise<MyDatabaseClient> {
  return new Promise((resolve, reject) => {
    function createObjectStore(
      db: IDBDatabase,
      storeName: string,
      options: IDBObjectStoreParameters,
    ): IDBObjectStore {
      if (DBOpenRequest.transaction == null) {
        throw new Error(
          'Error opening database. Open request transaction is null.',
        );
      }
      if (db.objectStoreNames.contains(storeName)) {
        return DBOpenRequest.transaction.objectStore(storeName);
      } else {
        return db.createObjectStore(storeName, options);
      }
    }
    function createIndex(
      store: IDBObjectStore,
      indexName: string,
      keyPath: Array<string>,
      options: IDBIndexParameters,
    ): void {
      if (store.indexNames.contains(indexName)) {
        return;
      } else {
        store.createIndex(indexName, keyPath, options);
      }
    }
    const DBOpenRequest = globalThis.indexedDB.open('MyDatabase', 3);
    DBOpenRequest.onerror = () => {
      reject(new Error('Error opening database: MyDatabase'));
    };
    DBOpenRequest.onsuccess = () => {
      const db = DBOpenRequest.result;
      resolve(createDatabaseClient(db));
    };
    DBOpenRequest.onupgradeneeded = () => {
      const db = DBOpenRequest.result;
      const AuthorsStore = createObjectStore(db, 'Authors', {
        keyPath: 'id',
        autoIncrement: true,
      });
      const PostsStore = createObjectStore(db, 'Posts', { keyPath: 'postId' });
      createIndex(AuthorsStore, 'name', ['name'], { unique: false });
      createIndex(AuthorsStore, 'email', ['email'], { unique: true });
      createIndex(PostsStore, 'name', ['name'], { unique: false });
      createIndex(PostsStore, 'name_author', ['name', 'author'], {
        unique: false,
      });
      createIndex(PostsStore, 'author', ['author'], { unique: false });
    };
  });
}
