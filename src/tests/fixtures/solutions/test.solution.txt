export type Value = 1 | 2 | 3;
export type Value2 = '1' | true | 0.2;
export type Value3 = Value | false;
export type Value4 = 'some';
export type Value5 = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
export type Value6 = {
  firstName: string;
  lastName: string;
};
export type Value7 = [string, Value6];
export type Authors = {
  id: number;
  name: string;
  email: string;
};
export type Post = {
  postId: string;
  name: string;
  content: string;
  author: number;
};
export type PostWithJoins = {
  postId: string;
  name: string;
  content: string;
  author: Authors;
};
export type AuthorsAddArgs = Omit<Authors, 'id'>;
export type PostsAddArgs = Post;
export type AuthorsPutArgs = AuthorsAddArgs | Authors;
export type PostsPutArgs = PostsAddArgs | Post;
export type AuthorsGetArgs =
  | number
  | {
      id: number;
    }
  | {
      name: string;
    }
  | {
      email: string;
    };
export type PostsGetArgs =
  | string
  | {
      postId: string;
    }
  | {
      name: string;
    }
  | {
      name: string;
      author: number;
    }
  | {
      author: number;
    };
const isAuthorsIdIndex = (
  arg: AuthorsGetArgs,
): arg is {
  id: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isAuthorsNameIndex = (
  arg: AuthorsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isAuthorsEmailIndex = (
  arg: AuthorsGetArgs,
): arg is {
  email: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'email')
  );
};
const isPostsPostIdIndex = (
  arg: PostsGetArgs,
): arg is {
  postId: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'postId')
  );
};
const isPostsNameIndex = (
  arg: PostsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isPostsNameAuthorIndex = (
  arg: PostsGetArgs,
): arg is {
  name: string;
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 2 &&
    Reflect.has(arg, 'name') &&
    Reflect.has(arg, 'author')
  );
};
const isPostsAuthorIndex = (
  arg: PostsGetArgs,
): arg is {
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'author')
  );
};
export type AuthorsClient = {
  add(
    arg: AuthorsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<number>;
  put(
    arg: AuthorsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<number>;
  get(
    arg: AuthorsGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  getAll(
    arg: AuthorsGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<ReadonlyArray<Authors>>;
};
export type PostsClient = {
  add(
    arg: PostsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<string>;
  put(
    arg: PostsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<string>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): Promise<PostWithJoins>;
  get(
    arg: PostsGetArgs,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): Promise<Post>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): Promise<Post | PostWithJoins>;
  getAll(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): Promise<ReadonlyArray<PostWithJoins>>;
  getAll(
    arg: PostsGetArgs,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): Promise<ReadonlyArray<Post>>;
  getAll(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>;
};
export type MyDatabaseClient = {
  transaction: (
    storeNames: Array<'Authors' | 'Posts'>,
    mode?: IDBTransactionMode,
  ) => IDBTransaction;
  authors: AuthorsClient;
  posts: PostsClient;
};
function createDatabaseClient(db: IDBDatabase): MyDatabaseClient {
  class AuthorsClientImpl {
    static tablesForTransaction: ReadonlyArray<string> = ['Authors'];
    add(
      arg: AuthorsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<number> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const DBAddRequest: IDBRequest = store.add(arg);
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            resolve(DBAddRequest.result);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: AuthorsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<number> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const DBPutRequest: IDBRequest = store.put(arg);
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            resolve(DBPutRequest.result);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    get(
      arg: AuthorsGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        if (isAuthorsIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else if (isAuthorsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isAuthorsEmailIndex(arg)) {
          const index: IDBIndex = store.index('email');
          DBGetRequest = index.get([arg.email]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    getAll(
      arg: AuthorsGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<ReadonlyArray<Authors>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        if (isAuthorsIdIndex(arg)) {
          DBGetRequest = store.getAll(arg.id);
        } else if (isAuthorsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.getAll([arg.name]);
        } else if (isAuthorsEmailIndex(arg)) {
          const index: IDBIndex = store.index('email');
          DBGetRequest = index.getAll([arg.email]);
        } else {
          DBGetRequest = store.getAll(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const authorsClient = new AuthorsClientImpl();
  class PostsClientImpl {
    static tablesForTransaction: ReadonlyArray<string> = ['Posts', 'Authors'];
    add(
      arg: PostsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<string> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Posts'], 'readwrite');
        const store = tx.objectStore('Posts');
        const DBAddRequest: IDBRequest = store.add(arg);
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            resolve(DBAddRequest.result);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: PostsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<string> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Posts'], 'readwrite');
        const store = tx.objectStore('Posts');
        const DBPutRequest: IDBRequest = store.put(arg);
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            resolve(DBPutRequest.result);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): Promise<PostWithJoins>;
    get(
      arg: PostsGetArgs,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): Promise<Post>;
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): Promise<Post | PostWithJoins> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        if (isPostsPostIdIndex(arg)) {
          DBGetRequest = store.get(arg.postId);
        } else if (isPostsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isPostsNameAuthorIndex(arg)) {
          const index: IDBIndex = store.index('name_author');
          DBGetRequest = index.get([arg.name, arg.author]);
        } else if (isPostsAuthorIndex(arg)) {
          const index: IDBIndex = store.index('author');
          DBGetRequest = index.get([arg.author]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: Post = (DBGetRequest as IDBRequest).result;
              if (options?.withJoins != false) {
                Promise.all([authorsClient.get(post.author)]).then(
                  ([author]) => {
                    resolve({
                      ...post,
                      author,
                    });
                  },
                );
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    getAll(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): Promise<ReadonlyArray<PostWithJoins>>;
    getAll(
      arg: PostsGetArgs,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): Promise<ReadonlyArray<Post>>;
    getAll(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        if (isPostsPostIdIndex(arg)) {
          DBGetRequest = store.getAll(arg.postId);
        } else if (isPostsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.getAll([arg.name]);
        } else if (isPostsNameAuthorIndex(arg)) {
          const index: IDBIndex = store.index('name_author');
          DBGetRequest = index.getAll([arg.name, arg.author]);
        } else if (isPostsAuthorIndex(arg)) {
          const index: IDBIndex = store.index('author');
          DBGetRequest = index.getAll([arg.author]);
        } else {
          DBGetRequest = store.getAll(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: ReadonlyArray<Post> = (DBGetRequest as IDBRequest)
                .result;
              if (options?.withJoins != false) {
                Promise.all(
                  post.map((result) => {
                    return Promise.all([authorsClient.get(result.author)]).then(
                      ([author]) => {
                        return {
                          ...result,
                          author,
                        };
                      },
                    );
                  }),
                ).then((result: ReadonlyArray<PostWithJoins>) => {
                  resolve(result);
                });
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const postsClient = new PostsClientImpl();
  return {
    transaction: (
      storeNames: Array<'Authors' | 'Posts'>,
      mode?: IDBTransactionMode,
    ): IDBTransaction => {
      return db.transaction(storeNames, mode);
    },
    authors: authorsClient,
    posts: postsClient,
  };
}
export function init(): Promise<MyDatabaseClient> {
  return new Promise((resolve, reject) => {
    const DBOpenRequest = globalThis.indexedDB.open('MyDatabase', 3);
    DBOpenRequest.onerror = () => {
      reject('Error opening database: MyDatabase');
    };
    DBOpenRequest.onsuccess = () => {
      const db = DBOpenRequest.result;
      resolve(createDatabaseClient(db));
    };
    DBOpenRequest.onupgradeneeded = () => {
      const db = DBOpenRequest.result;
      const AuthorsStore = db.createObjectStore('Authors', {
        keyPath: 'id',
        autoIncrement: true,
      });
      const PostsStore = db.createObjectStore('Posts', { keyPath: 'postId' });
      AuthorsStore.createIndex('name', ['name'], { unique: false });
      AuthorsStore.createIndex('email', ['email'], { unique: true });
      PostsStore.createIndex('name', ['name'], { unique: false });
      PostsStore.createIndex('name_author', ['name', 'author'], {
        unique: false,
      });
      PostsStore.createIndex('author', ['author'], { unique: false });
    };
  });
}
